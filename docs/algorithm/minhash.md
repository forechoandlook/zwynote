[TOC]


### MinHash 工作原理
MinHash 是一种用于快速估计集合相似度（如Jaccard相似度）的算法，核心步骤如下：

1. **Jaccard相似度**：对于集合A和B，其Jaccard相似度为 \( J(A,B) = \frac{|A \cap B|}{|A \cup B|} \)。  
2. **哈希函数转换**：  
    - 对集合中的每个元素应用一个随机哈希函数 \( h \)，生成哈希值。  
    - 保留每个集合的最小哈希值（MinHash），即 \( \min(h(A)) \) 和 \( \min(h(B)) \)。  
3. **相似度估计**：  
    - 若 \( \min(h(A)) = \min(h(B)) \)，则两集合的MinHash值相同。  
    - 通过多个哈希函数重复此过程，MinHash值相同的比例即为Jaccard相似度的无偏估计。

### 提出时间
MinHash 由 **Andrei Broder** 在1997年首次提出，用于解决 AltaVista 搜索引擎中网页去重和相似文档检测的问题。

---

### 改进方法
1. **多个哈希函数（k个）**：  
   - 原始方法需多个独立哈希函数，计算开销大。改进方案如 **Permutation Hashing**（通过排列模拟哈希）减少计算量。

2. **One Permutation Hashing (OPH)**：  
   - 将元素哈希到一个桶中，仅保留每个桶的最小值，显著降低计算复杂度（Li et al., 2012）。

3. **B-bit MinHash**：  
   - 仅存储MinHash的最低 \( b \) 位（如1-bit），减少存储空间，但需调整相似度计算（Li & König, 2010）。

4. **Weighted MinHash**：  
   - 扩展至加权集合（如TF-IDF），通过调整哈希函数处理元素权重（Ioffe, 2010）。

5. **Locality-Sensitive Hashing (LSH)**：  
   - 结合LSH将相似项分到相同桶中，适用于近邻搜索。

---

### 缺陷及克服方法
1. **高维数据计算开销大**：  
   - **问题**：需大量哈希函数保证精度。  
   - **解决**：使用OPH或B-bit MinHash降低计算/存储需求。

2. **哈希冲突**：  
   - **问题**：不同元素可能哈希到相同值。  
   - **解决**：采用强哈希函数（如MurmurHash3）减少冲突。

3. **仅适用于集合数据**：  
   - **问题**：直接处理连续数据或复杂特征困难。  
   - **解决**：加权MinHash或特征离散化。

4. **长尾分布偏差**：  
   - **问题**：稀有元素可能被忽略。  
   - **解决**：结合重要性采样或加权方案。

5. **动态数据更新困难**：  
   - **问题**：新增元素需重新计算MinHash。  
   - **解决**：增量式MinHash（如维护最小值的堆结构）。

---

### 总结
MinHash 通过最小哈希值高效估计相似度，改进方法聚焦于降低计算/存储成本（如OPH、B-bit）和扩展应用场景（如加权MinHash）。缺陷可通过算法优化（如增量更新）和结合其他技术（如LSH）克服，使其在大规模数据中保持实用性。


### **MinHash 工作原理详解（举例说明）**
MinHash 的核心思想是通过哈希函数将集合映射为紧凑的签名（signature），从而高效估计集合的 Jaccard 相似度。我们通过一个具体例子来说明。

#### **1. 定义问题**
假设有两个集合：
- **A = {“apple”, “banana”, “orange”}**
- **B = {“apple”, “pear”, “grape”}**

计算它们的 **Jaccard 相似度**：
$J(A, B) = \frac{|A \cap B|}{|A \cup B|} = \frac{1}{5} = 0.2$
（因为 `A ∩ B = {“apple”}`，`A ∪ B = {“apple”, “banana”, “orange”, “pear”, “grape”}`）

但直接计算在大规模数据（如百万级网页去重）时效率低，MinHash 可以高效估计这个值。

---

#### **2. MinHash 计算步骤**
**(1) 构建哈希函数**
假设我们使用 3 个哈希函数（实际可能需要更多）：

- \( h_1(x) = (x \cdot 1 + 1) \mod 5 \)
- \( h_2(x) = (x \cdot 2 + 1) \mod 5 \)
- \( h_3(x) = (x \cdot 3 + 1) \mod 5 \)

（注：这里简单用数字代表单词，如 `“apple”=1`, `“banana”=2`, `“orange”=3`, `“pear”=4`, `“grape”=5`）

**(2) 计算每个集合的 MinHash**

- **集合 A = {1, 2, 3}**
  - \( h_1 \) 哈希值：\( h_1(1)=2 \), \( h_1(2)=0 \), \( h_1(3)=2 \) → MinHash = `min(2, 0, 2) = 0`
  - \( h_2 \) 哈希值：\( h_2(1)=3 \), \( h_2(2)=0 \), \( h_2(3)=2 \) → MinHash = `min(3, 0, 2) = 0`
  - \( h_3 \) 哈希值：\( h_3(1)=4 \), \( h_3(2)=2 \), \( h_3(3)=0 \) → MinHash = `min(4, 2, 0) = 0`
  - **A 的 MinHash 签名 = [0, 0, 0]**

- **集合 B = {1, 4, 5}**
  - \( h_1 \) 哈希值：\( h_1(1)=2 \), \( h_1(4)=0 \), \( h_1(5)=1 \) → MinHash = `min(2, 0, 1) = 0`
  - \( h_2 \) 哈希值：\( h_2(1)=3 \), \( h_2(4)=4 \), \( h_2(5)=1 \) → MinHash = `min(3, 4, 1) = 1`
  - \( h_3 \) 哈希值：\( h_3(1)=4 \), \( h_3(4)=3 \), \( h_3(5)=1 \) → MinHash = `min(4, 3, 1) = 1`
  - **B 的 MinHash 签名 = [0, 1, 1]**

**(3) 估计 Jaccard 相似度**
比较两个签名的相同位置：

- 第 1 位：0 == 0 ✔  
- 第 2 位：0 ≠ 1 ✖  
- 第 3 位：0 ≠ 1 ✖  

相似度估计 = **1/3 ≈ 0.333**（真实值 0.2，误差来自哈希函数太少）。

---

### **改进方法（附例子说明）**
#### **1. One Permutation Hashing (OPH)** 
**问题**：传统 MinHash 需要多个独立哈希函数，计算成本高。  
**改进**：仅用 **一次排列（permutation）** 分割数据到多个桶，每个桶取最小值。

**例子**：

- 假设哈希范围是 0-9，分成 2 个桶（桶大小=5）：
  - 集合 A = {1, 2, 3} → 哈希到桶 0: {1,2,3}, 桶 1: {}  
    - 桶 0 的最小值 = 1，桶 1 为空（用特殊值填充，如 ∞）  
    - A 的签名 = [1, ∞]  
  - 集合 B = {1, 4, 5} → 桶 0: {1,4}, 桶 1: {5}  
    - 桶 0 的最小值 = 1，桶 1 的最小值 = 5  
    - B 的签名 = [1, 5]  
- 相似度估计：仅第 1 位相同 → 1/2 = 0.5（需调整空桶的影响）。

---

#### **2. B-bit MinHash**
**问题**：MinHash 签名存储成本高（如 64-bit 整数）。  
**改进**：只保留 MinHash 的最低 **b 位**（如 1-bit），大幅减少存储。

**例子**：
- 假设原 MinHash 签名 A = [5 (101), 3 (011), 6 (110)]  
- 取 1-bit MinHash：  
  - 5 → 1, 3 → 1, 6 → 0  
  - 新签名 = [1, 1, 0]  
- 相似度计算时需校正（因为 1-bit 会引入偏差）。

---

#### **3. Weighted MinHash**
**问题**：传统 MinHash 仅适用于二元集合（存在/不存在），无法处理权重（如 TF-IDF）。  
**改进**：调整哈希函数，使高权重元素更可能被选为 MinHash。

**例子**：

- 集合 A = {(“apple”, 0.9), (“banana”, 0.2)}  
- 加权 MinHash 会倾向于选择 `“apple”`，因其权重更高。

---

### **总结**
- **MinHash 本质**：通过最小哈希值估计集合相似度，适合大规模去重、推荐系统等场景。  
- **改进方向**：  
  - **降低计算成本**：OPH（单排列哈希）。  
  - **减少存储**：B-bit MinHash。  
  - **支持复杂数据**：Weighted MinHash（加权集合）。  
- **实际应用**：  
  - 网页去重（如 Google 爬虫）、  
  - 协同过滤（用户-物品相似度计算）。